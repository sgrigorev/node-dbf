// Generated by CoffeeScript 1.12.7
(function() {
  var EventEmitter, Header, HeaderFPT, Parser, fs, iconv,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  Header = require('./header');

  HeaderFPT = require('./header_fpt');

  fs = require('fs');

  iconv = require('iconv-lite');

  Parser = (function(superClass) {
    extend(Parser, superClass);

    function Parser(filename, encoding, fpt_filename) {
      var base_filename;
      this.filename = filename;
      this.encoding = encoding != null ? encoding : 'utf-8';
      this.fpt_filename = fpt_filename;
      this.parseField = bind(this.parseField, this);
      this.parseMemoRecord = bind(this.parseMemoRecord, this);
      this.parseRecord = bind(this.parseRecord, this);
      this.parse = bind(this.parse, this);
      if (!this.fpt_filename) {
        base_filename = this.filename.split('.dbf')[0];
        this.fpt_filename = base_filename + ".fpt";
      }
    }

    Parser.prototype.parse = function() {
      this.emit('start', this);
      this.header = new Header(this.filename, this.encoding);
      fs.exists(this.fpt_filename, (function(_this) {
        return function(exists) {
          if (exists) {
            _this.header_fpt = new HeaderFPT(_this.fpt_filename, _this.encoding);
            _this.header_fpt.parse(function(err) {});
            _this.emit('header_fpt', _this.header_fpt);
            return _this.fpt_buffer = fs.readFileSync(_this.fpt_filename);
          }
        };
      })(this));
      this.header.parse((function(_this) {
        return function(err) {
          var bufLoc, loc, overflow, readBuf, sequenceNumber, stream;
          _this.emit('header', _this.header);
          sequenceNumber = 0;
          loc = _this.header.start;
          bufLoc = _this.header.start;
          overflow = null;
          stream = fs.createReadStream(_this.filename);
          readBuf = function() {
            var buffer;
            while (buffer = stream.read()) {
              if (bufLoc !== _this.header.start) {
                bufLoc = 0;
              }
              if (overflow !== null) {
                buffer = Buffer.concat([overflow, buffer]);
              }
              while (loc < (_this.header.start + _this.header.numberOfRecords * _this.header.recordLength) && (bufLoc + _this.header.recordLength) <= buffer.length) {
                _this.emit('record', _this.parseRecord(++sequenceNumber, buffer.slice(bufLoc, bufLoc += _this.header.recordLength)));
              }
              loc += bufLoc;
              if (bufLoc < buffer.length) {
                overflow = buffer.slice(bufLoc, buffer.length);
              } else {
                overflow = null;
              }
              return _this;
            }
          };
          stream.on('readable', readBuf);
          return stream.on('end', function() {
            return _this.emit('end');
          });
        };
      })(this));
      return this;
    };

    Parser.prototype.parseRecord = function(sequenceNumber, buffer) {
      var field, fn, i, len, loc, record, ref;
      record = {
        '__sequenceNumber': sequenceNumber,
        '__deleted': (buffer.slice(0, 1))[0] !== 32
      };
      loc = 1;
      ref = this.header.fields;
      fn = (function(_this) {
        return function(field) {
          return record[field.name] = _this.parseField(field, buffer.slice(loc, loc += field.length));
        };
      })(this);
      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        fn(field);
      }
      return record;
    };

    Parser.prototype.parseMemoRecord = function(block_position) {
      var block_header_end, block_header_start, block_size, end, start;
      if (block_position > this.header_fpt.nextFreeBlock) {
        return '';
      }
      block_header_start = block_position * this.header_fpt.memoSingleBlockLength;
      block_header_end = block_header_start + 8;
      block_size = this.fpt_buffer.slice(block_header_start + 4, block_header_end).readInt32BE(0);
      if (block_size === 0 || void 0 || block_size > 2048) {
        return '';
      }
      start = block_header_end;
      end = start + block_size;
      if (end > this.fpt_buffer.length) {
        return '';
      }
      return (iconv.decode(this.fpt_buffer.slice(start, end), this.encoding)).trim();
    };

    Parser.prototype.parseField = function(field, buffer) {
      var A, B, C, D, E, F, W, X, block_position, d, day, f, month, t, value, year;
      value = (iconv.decode(buffer, this.encoding)).trim();
      switch (field.type) {
        case 'M':
          if (!this.header_fpt) {
            throw new Error("Memo field was specified but related .FPT file (" + this.fpt_filename + ") was not found for " + this.filename + ".");
          }
          block_position = buffer.readInt32LE(0);
          if (block_position === 0) {
            value = '';
          } else {
            value = this.parseMemoRecord(block_position);
          }
          break;
        case 'N':
          value = parseFloat(value);
          break;
        case 'I':
          value = buffer.readInt32LE(0);
          break;
        case 'L':
          value = value === 'T' ? true : false;
          break;
        case 'D':
          if (value) {
            year = parseInt(value.slice(0, 4));
            month = parseInt(value.slice(4, 6)) - 1;
            day = parseInt(value.slice(6, 8));
            value = new Date(year, month, day);
          } else {
            value = null;
          }
          break;
        case 'T':
          d = buffer.readInt32LE(0);
          t = buffer.readInt32LE(4);
          value = null;
          if (d > 0) {
            f = Math.floor;
            W = f((d - 1867216.25) / 36524.25);
            X = f(W / 4);
            A = d + 1 + W - X;
            B = A + 1524;
            C = f((B - 122.1) / 365.25);
            D = f(365.25 * C);
            E = f((B - D) / 30.6001);
            F = f(30.6001 * E);
            day = B - D - F;
            month = E <= 13 ? E - 2 : E - 14;
            year = month <= 1 ? C - 4715 : C - 4716;
            value = new Date(year, month, day);
            value.setMilliseconds(value.getMilliseconds() + t);
          }
          break;
        default:
          value;
      }
      return value;
    };

    return Parser;

  })(EventEmitter);

  module.exports = Parser;

}).call(this);
